#include <arpa/inet.h>  // for ntohs()

std::vector<ScanPoint> LiDARReader::readScan() {
  std::vector<ScanPoint> scan(BLOCKS_PER_SCAN * POINTS_PER_BLOCK);
  MSOP_Data_t packet;

  // 1) sync on block0
  do {
    recvPacket(packet);
  } while (packet.BlockID[0].Azimuth != 0);

  // convert block0 fields
  packet.BlockID[0].DataFlag = ntohs(packet.BlockID[0].DataFlag);
  packet.BlockID[0].Azimuth  = ntohs(packet.BlockID[0].Azimuth);
  for(int i=0;i<POINTS_PER_BLOCK;i++){
    packet.BlockID[0].Result[i].Dist_1 = ntohs(packet.BlockID[0].Result[i].Dist_1);
    // RSSI_1 is a byte, no swap needed
  }

  double resolution = (packet.BlockID[1].Azimuth - packet.BlockID[0].Azimuth)
                      / static_cast<double>(POINTS_PER_BLOCK);

  // 2) read blocks 1..11
  for (int b = 0; b < BLOCKS_PER_SCAN; ++b) {
    if (b > 0) {
      recvPacket(packet);
      packet.BlockID[b].DataFlag = ntohs(packet.BlockID[b].DataFlag);
      packet.BlockID[b].Azimuth  = ntohs(packet.BlockID[b].Azimuth);
      for(int i=0;i<POINTS_PER_BLOCK;i++){
        packet.BlockID[b].Result[i].Dist_1 = ntohs(packet.BlockID[b].Result[i].Dist_1);
      }
    }

    for (int i = 0; i < POINTS_PER_BLOCK; ++i) {
      auto &blk = packet.BlockID[b];
      // Now DataFlag will read 0xEEFF correctly
      if (blk.DataFlag != 0xEEFF) continue;

      double raw_ang = blk.Azimuth + resolution * i + angle_offset_;
      double ang_rad = raw_ang * M_PI / 180.0;
      double dist_m  = blk.Result[i].Dist_1 / 1000.0;
      double inten   = blk.Result[i].RSSI_1;
      if (dist_m <= 0) { dist_m = INF_DIST; inten = 0; }

      int idx = b*POINTS_PER_BLOCK + i;
      if (inverted_) idx = BLOCKS_PER_SCAN*POINTS_PER_BLOCK - 1 - idx;
      scan[idx] = { ang_rad, dist_m, inten };
    }
  }

  return scan;
}
